#include <iostream>
#include <fstream> 
#include <vector>

using namespace std;

const char readPath[] = "D:\\input.txt";
const char writePath[] = "input.txt";

void printLogo(int task) {
	printf("************************************************************\n"
		"* Nizhniy Novgorod Technical University                    *\n");
	printf("* Study work number 2. Task number %d.                      *\n", task);
	printf("* Performed student 18 - IVT - 2. Kornilov Alexey          *\n"
		"************************************************************\n");
}

void sleep() {
	system("pause");
	cout << endl;
}

void myCls(int task) {
	system("cls");
	printLogo(task);
}

void jobDone() {
	cout << endl;
	puts("\nJob done.");
	cout << endl;
	sleep();
}

size_t getLineTextSize() {
	size_t textSize = 0; //Число символов в файле
	char symbolBuf; //буффер для подсчета символов

	ifstream ifs(readPath);
	if (!ifs) {
		cout << "don't open file" << endl;
		exit(1);
	}
	else
	{
		while (!ifs.eof())
		{
			ifs.get(symbolBuf);
			textSize++;
		}

	}
	ifs.close();

	return textSize;
}

char* read(size_t textSize) {
	char *textBuf = new char[textSize]; //Выделяем память по определенному числу символов
	for (int i = 0; i < textSize; i++) {
		textBuf[i] = NULL; //Очищаем строку от хлама
	}
	ifstream f2(readPath);  //создаем поток для работы с файлом
	int pos = 0; //куроср на текущий символ (как номер буквы в слове)

	while (!f2.eof()) //Проходим ао файлу
	{
		f2.get(textBuf[pos]); //Записываем симыол за символом 
		pos++; //передвинули курсор для записи следующего символа
	}

	f2.close(); //закончили работу с файлом

	return textBuf;
}

bool isSystemSymbolOrSpace(char symbol) {
	if ( (symbol == ' ') || (symbol == '\0') || (symbol == '\a') || (symbol == '\b') || (symbol == '\t') || (symbol == '\n') || (symbol == '\v') || (symbol == '\f') || (symbol == '\r')) {
		//puts("\nyes");
		return true;
	}
	else {
		//puts("\nmo");
		return false;
	}
}

size_t getCountSystemsSymbols(char * txt, size_t textLineSize) {
	size_t count = 0;
	for (size_t i = 0; i < textLineSize; i++) {
		if (isSystemSymbolOrSpace(txt[i])){
			count++;
		}
	}
	return count;
}


int main() {
	setlocale(LC_ALL, "Russian");
	//setlocale(LC_ALL, ".866");

	while (true)
	{
		int task = 0;

		myCls(task);
		cout
			<< "Tasks.The source of the data and the result of the program is textual." << endl
			<< "file.For coding tex, the DOS code table (CP866) is used." << endl
			<< "Create a program that processes the file according to the specified the algorithm" << endl << endl;

		size_t lineTextSize = getLineTextSize();

		char *lineText = new char[lineTextSize];
		lineText = read(lineTextSize);

		{
			cout << lineText << endl;//dbg dell
			cout << lineTextSize << endl;//dbg dell
			cout << getCountSystemsSymbols(lineText, lineTextSize) << endl;//dbg dell
		}


		// line text to mas
		size_t masTextSize = 0;
		size_t tmpLen = 0;
		size_t tmpI = 0;
		bool end = false;
		size_t countSystemsSymbols = getCountSystemsSymbols(lineText, lineTextSize);
		char** masText = new char* [countSystemsSymbols];

		for (size_t i = 0; i < lineTextSize; i++) {
			char symbol = lineText[i];

			if (isSystemSymbolOrSpace(lineText[i])) {
				end = true;
			}
			else {
				tmpLen++;
			}

			if (end) {
				size_t left = tmpI;
				size_t right = left + tmpLen + 1;


				cout << "LEFT " << left << endl;
				cout << "len " << tmpLen << endl;
				cout << "right " << right << endl;

				masText[masTextSize] = new char[tmpLen] + 1;
				size_t tmpPos = 0;
					for (size_t i = left; i < right; i++) {
						masText[masTextSize][tmpPos]= lineText[i];
						tmpPos++;
				}
					tmpPos = 0;
					masText[masTextSize][tmpLen + 1] = '\0';
				cout << "newCell " << masText[masTextSize] << endl << endl;
				masTextSize++;
				end = false;
				tmpI = i + 1;
				tmpLen = 0;
			}
		}



		cout << endl << "mas" << endl << endl;

		for (size_t i = 0; i < masTextSize; i++) {
			cout << "i "<< i <<"      " << masText[i] << endl;
		}

		jobDone();
//освобождаем память


	}
}
